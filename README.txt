При дебаге на стандартном MIT Scheme дебажить невозможно: никакой информации об ошибках не появляется.
В этом интерпретаторе это должно быть.

Интерпретатор поставляет простейшую реализацию SCHEME без наворотов, с помощью которой можно реализовать свой scheme
из 4 главы.

Арифметика сохраняется:
(+ 5 5) -> 10
(+ (- 10 2) 2) -> 10
(- 10 10) -> 0
...

Присутствует if:
(if (= 10 10) "Hello" "Goodbye") -> "Hello"

Присутствует cond:
(cond ((eq? x 10) "x == 10")
      ((eq? x 11) "x == 11"))
      ...

Строки не поддерживают экранирования символов:
"Hello, world" -> "Hello, world"
"Hello\\world" -> "Hello\\world"
"Hello\"world" -> Not OK!

cons, car, cdr, cadr, cddr...
(cons 1 2) -> (1 . 2)
(car (cons 1 2)) -> 1
(cdr (cons 1 2)) -> 2
(cadr (list 1 2)) -> 2
(cddr (list 1 2)) -> nil

define:
(define (x) (+ 1 2))

lambda:
(lambda (x) (+ x x))

quote:
(quote (1 2 3)) == '(1 2 3)

eq? equal? =
(eq? x x)
(equal? x y)
(= 10 10)

типы:
number, string, symbol, procedure

Интерпретатор максимально прост, поэтому все остальное реализуется через надлисповые диалекты
